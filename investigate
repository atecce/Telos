#!/usr/bin/env python
#
# I should not like my writing to spare other people the trouble of thinking. 
# But, if possible, to stimulate someone to thoughts of their own.
#

class database:

	import MySQLdb

	canvas = MySQLdb.connect('localhost', 'root')
	brush  = canvas.cursor()

	try: 

		brush.execute("create database lyrics_net")
		canvas.close()

	except: canvas.close()

	canvas = MySQLdb.connect('localhost', 'root', db ='lyrics_net')
	brush  = canvas.cursor()

	brush.execute("""create table if not exists artists (
								  
				name varchar(255) not null, 	  
				       			  
				primary key (name) 		  
				       			  
				)""")

	brush.execute("""create table if not exists albums ( 		
				       					
				title varchar(255) not null, 			
										
				artist_name varchar(255) not null,  		
				       					
				primary key (title, artist_name), 				
				foreign key (artist_name) references artists (name) 
				       					
				)""")

	brush.execute("""create table if not exists songs ( 	    	       
				       				       
				title varchar(255) not null, 	    	       
									       
				album_title varchar(255) not null, 	    	       
				       				       
				lyrics text, 			    	       
				       				       
				primary key (album_title, title),
				foreign key (album_title) references albums (title) 
				       				       
				)""")

	canvas.close()

	def draw(self, query, args):

		# sketch the outline
		canvas = self.MySQLdb.connect('localhost', 'root', db='lyrics_net')
		brush  = canvas.cursor()

		brush.execute(query, args)
		canvas.commit()

		canvas.close()

	def caught_up(self, song, album):

		# compare yourself to others
		canvas = self.MySQLdb.connect('localhost', 'root', db='lyrics_net')
		brush  = canvas.cursor()

		if brush.execute("select title, album_title from songs where title=%s and album_title=%s", (song, album)):
			
			canvas.close()
			return True

		canvas.close()

class lyrics_site:

	# be patient
	import time

	# but don't wait for your neighbors
	import multiprocessing

	# and focus
	branching_factor = 8

	# but keep it playful
	from random import sample, shuffle

	# set the canvas
	canvas = database()

	def communicate(self, url):

		from bs4 import BeautifulSoup
		import requests

		# never stop trying
		while True:

			# make some soup
			try:

				page = requests.get(url)
				soup = BeautifulSoup(page.content)

				return soup

			# give communication a chance
			except requests.exceptions.ConnectionError: pass

			self.time.sleep(1)

	def multitask(self, processes, process_name, process_target, process_args):

			process = self.multiprocessing.Process(name=process_name, target=process_target, args=process_args)

			processes.add(process)

			process.start()

			alive =  [(process.name, process.is_alive()) for process in processes if process.is_alive()]
			
			while len(alive) >= self.branching_factor:

				alive =  [(process.name, process.is_alive()) for process in processes if process.is_alive()]

				self.time.sleep(1)

class lyrics_net(lyrics_site): 

	# get some inspiration
	url = 'http://www.lyrics.net/'

	def investigate(self):

		# need this to understand the text
		import re

		# talk to the text
		soup = self.communicate(self.url)

		alphabet_urls = (self.url + re.match('^/artists/[A-Z0]$', link.get('href')).group(0) + '/99999'      \
				 for link in self.sample(soup.find_all('div', {'id': 'page-letter-search'})[0],      \
				 	                 len(soup.find_all('div', {'id': 'page-letter-search'})[0])) \
				          if re.match('^/artists/[A-Z0]$', str(link.get('href'))))

		print "\nTagging..."
		
		start = self.time.time()

		artist_tags = [trace.strong.a 		  		     			       	    \
			       for alphabet_url in alphabet_urls 	     			       	    \
			       for trace in self.sample(self.communicate(alphabet_url).find_all('tr'), 	    \
			       				len(self.communicate(alphabet_url).find_all('tr'))) \
			       		 if trace.strong]

		print "Tagging", len(artist_tags), "artist tags took", self.time.time() - start, "seconds"

		self.time.sleep(5)

		self.shuffle(artist_tags)

		artist_data = ((artist_tag.text, self.url + artist_tag.get('href')) for artist_tag in artist_tags)

		for artist_name, artist_url in artist_data: self.multitask(priests, artist_name, self.honor, (artist_name, artist_url,))

	def honor(self, artist_name, artist_url):

		self.canvas.draw("""insert into artists (name)
					   values (%s)
					   on duplicate key update
					   name = name""",
					   [artist_name])

		print "\nArtist:", artist_name, "\ninserted"

		soup = self.communicate(artist_url)

		for album_label in self.sample(soup.find_all('h3', {'class': 'artist-album-label'}), \
					   len(soup.find_all('h3', {'class': 'artist-album-label'}))): 

			album_url   = self.url + album_label.a.get('href')
			album_title = album_label.a.text

			self.multitask(masses, album_title, self.admire, (artist_name, album_url, album_title,))

	def admire(self, artist_name, album_url, album_title):

		self.canvas.draw("""insert into albums (artist_name, title)
					   values (%s, %s)
					   on duplicate key update
					   artist_name = artist_name, title = title""",
					   [artist_name, album_title])

		print "\n\tArtist:", artist_name, "\n\tAlbum:", album_title, "\n\tinserted"

		soup = self.communicate(album_url)

		if soup.find_all('body', {'id': 's4-page-homepage'}): 
			
			print "\tArtist:", artist_name, "\n\tAlbum:", album_title, "\n\tredirects to home page\n"
			return

		song_data = ((self.url + song_tag.a.get('href'), song_tag.a.text)  \
			     for song_tag in self.sample(soup.find_all('strong'),  \
			     			     len(soup.find_all('strong'))) \
			     		  if song_tag.a)

		for song_url, song_title in song_data:

			# don't repeat yourself
			if self.canvas.caught_up(song_title, album_title): 
				
				print "\n\t\tSong:", song_title, "\n\t\tAlbum:", album_title, "\n\t\talready completed\n"
				continue
			
			self.multitask(prayers, song_title, self.experience, (album_title, song_url, song_title,))

	def experience(self, album_title, song_url, song_title):

		soup = self.communicate(song_url)

		# TODO
		# don't go home too early
		if soup.find_all('body', {'id': 's4-page-homepage'}): 
			
			print "\n\t\tSong:", song_title, "\n\t\tAlbum:", album_title, "\n\t\tredirects to home page\n"
			return

		try: lyrics = soup.find_all('pre', {'id': 'lyric-body-text'})[0].text

		except IndexError: return

		# please kneel
		self.canvas.draw("""insert into songs (album_title, title, lyrics)
					   values (%s, %s, %s)
					   on duplicate key update
					   album_title = album_title, title = title, lyrics = lyrics""",
					   [album_title, song_title, lyrics])

		print "\t\tSong:", song_title, "\n\t\tAlbum:", album_title, "\n\t\tinserted\n"

		print

		for line in lyrics.splitlines(): print '\t\t\t', line

		print

if __name__ == '__main__':

	priests = set()
	masses  = set()
	prayers = set()

	investigation = lyrics_net()

	investigation.investigate()
